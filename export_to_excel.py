#!/usr/bin/env python3
"""
Export ENTSO-E price data to Excel format.

This script converts the CSV files generated by entso_py_retriever.py to Excel format.
It creates a single Excel file with multiple sheets for the different data types.

Usage:
    python export_to_excel.py
"""

import pandas as pd
import os
import logging
import sys
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def format_excel_sheet(writer, sheet_name):
    """
    Apply formatting to Excel sheet.
    
    Args:
        writer: ExcelWriter object
        sheet_name: Name of the sheet to format
    """
    # Note: This function is a placeholder for future formatting
    # The openpyxl engine doesn't support the same formatting options as XlsxWriter
    # For now, we'll skip the formatting
    pass

def main():
    """
    Main function to export CSV files to Excel format.
    """
    logger.info("Starting export to Excel")
    
    # Check if CSV files exist
    csv_files = [f for f in os.listdir('.') if f.endswith('.csv')]
    if not csv_files:
        logger.error("No CSV files found. Please run entso_py_retriever.py first.")
        sys.exit(1)
    
    # Determine which countries are included in the data
    country_codes = set()
    for file in csv_files:
        # Extract country code from file name (e.g., nl_price_metrics_local_CEST.csv -> nl)
        if file.startswith(('combined_', 'all_')):
            country_codes.add('combined')
        else:
            parts = file.split('_')
            if len(parts) > 0:
                country_code = parts[0].upper()
                if len(country_code) <= 2:  # Most country codes are 2 letters
                    country_codes.add(country_code)
    
    # Create a string with the country codes
    countries_str = '_'.join(sorted(country_codes))
    if not countries_str:
        countries_str = 'unknown'
    
    # Create Excel writer
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    excel_file = f'entso_price_data_{countries_str}_{timestamp}.xlsx'
    
    with pd.ExcelWriter(excel_file, engine='openpyxl') as writer:
        # Create summary sheet
        logger.info("Creating summary sheet")
        
        # Create a more descriptive title based on the countries
        if len(country_codes) == 1:
            if 'combined' in country_codes:
                title = 'ENTSO-E Day-Ahead Price Data for Multiple Countries (Combined)'
            else:
                title = f'ENTSO-E Day-Ahead Price Data for {", ".join(country_codes)}'
        else:
            title = f'ENTSO-E Day-Ahead Price Data for {", ".join(country_codes)}'
        
        summary_df = pd.DataFrame({
            'Description': [
                title,
                f'Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
                f'Countries included: {", ".join(sorted(country_codes))}',
                '',
                'Sheet Contents:',
                '- Daily Metrics (Local Time): Min, Max, and Weighted Average prices per day in local timezone',
                '- Daily Metrics (UTC): Min, Max, and Weighted Average prices per day in UTC timezone',
                '- Raw Prices (Local Time): Hourly price data in local timezone',
                '- Raw Prices (UTC): Hourly price data in UTC timezone',
                '',
                'Price Unit: EUR/MWh',
                '',
                'Note: The weighted average is calculated as the average price over all hours of the day.'
            ]
        })
        summary_df.to_excel(writer, sheet_name='Summary', index=False, header=False)
        
        # Set column width for summary sheet
        worksheet = writer.sheets['Summary']
        # Adjust column width (openpyxl method)
        worksheet.column_dimensions['A'].width = 100
        
        # Export metrics files
        metrics_files = [f for f in csv_files if 'price_metrics' in f]
        for file in metrics_files:
            # Get sheet name from file name
            if 'local_CEST' in file:
                sheet_name = 'Daily Metrics (Local Time)'
            elif 'utc' in file:
                sheet_name = 'Daily Metrics (UTC)'
            else:
                sheet_name = file.replace('.csv', '')
                if len(sheet_name) > 31:  # Excel sheet name length limit
                    sheet_name = sheet_name[:31]
            
            # Read CSV file
            logger.info(f"Exporting {file} to sheet {sheet_name}")
            df = pd.read_csv(file)
            
            # Convert date column to datetime
            if 'date' in df.columns:
                df['date'] = pd.to_datetime(df['date'])
            
            # Write to Excel
            df.to_excel(writer, sheet_name=sheet_name, index=False)
        
        # Export raw price files (first 10000 rows only to avoid Excel limitations)
        raw_files = [f for f in csv_files if 'raw_prices' in f]
        for file in raw_files:
            # Get sheet name from file name
            if 'local_CEST' in file:
                sheet_name = 'Raw Prices (Local Time)'
            elif 'utc' in file:
                sheet_name = 'Raw Prices (UTC)'
            else:
                sheet_name = file.replace('.csv', '')
                if len(sheet_name) > 31:  # Excel sheet name length limit
                    sheet_name = sheet_name[:31]
            
            # Read CSV file
            logger.info(f"Exporting {file} to sheet {sheet_name} (first 10000 rows)")
            df = pd.read_csv(file)
            
            # Convert datetime column to datetime
            if 'datetime' in df.columns:
                try:
                    # Try to convert to datetime and remove timezone
                    df['datetime'] = pd.to_datetime(df['datetime'], utc=True).dt.tz_localize(None)
                except Exception as e:
                    # If that fails, try a more robust approach
                    logger.warning(f"Error converting datetime: {e}")
                    # Convert to string first to avoid timezone issues
                    df['datetime'] = df['datetime'].astype(str)
                    # Then parse as datetime without timezone
                    df['datetime'] = pd.to_datetime(df['datetime'].str.split('+').str[0])
            
            # Take only the first 10000 rows to avoid Excel limitations
            if len(df) > 10000:
                logger.warning(f"File {file} has {len(df)} rows, truncating to 10000 rows for Excel compatibility")
                df = df.head(10000)
            
            # Write to Excel
            df.to_excel(writer, sheet_name=sheet_name, index=False)
    
    logger.info(f"Export completed. Data saved to {excel_file}")

if __name__ == "__main__":
    main()
